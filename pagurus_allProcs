#!/usr/bin/env python3
import argparse

from time import sleep
from datetime import datetime
import os
import logging
import sys
import signal

try:
    import psutil
except ImportError:
    print("Error: Install psutil to get statistics!", file=sys.stderr)

global system_procs
system_procs = []


# https://stackoverflow.com/questions/18499497/how-to-process-sigterm-signal-gracefully
class GracefulKiller:
  kill_now = False
  def __init__(self):
    signal.signal(signal.SIGINT, self.exit_gracefully)
    signal.signal(signal.SIGTERM, self.exit_gracefully)

  def exit_gracefully(self, *args):
    self.kill_now = True


def read_cgroup_mem():
    # /sys/fs/cgroup/memory/slurm/uid_95745/job_50480950/step_0
    with open('/sys/fs/cgroup/memory/memory.usage_in_bytes', 'r') as mem:
        total_mem = mem.read()

    return int(total_mem)

def read_cgroup_cpu(cpu_type='user'):
    with open(f'/sys/fs/cgroup/cpu/cpuacct.usage_percpu_{cpu_type}', 'r') as cpus:
        total_cpu = cpus.read()

    return [int(c) for c in total_cpu.split(" ")[:-1]]


def get_all_user_procs(username=None):
    total_procs = psutil.pids()
    user_procs = []
    if username is None:
        username = os.getlogin()

    for p in total_procs:
        p = int(p)
        if p in system_procs:
            continue

        try:
            user = psutil.Process(p).username()
        except psutil.NoSuchProcess:
            continue

        if username == user:
            user_procs.append(p)
        else:
            system_procs.append(p)

    return user_procs

    

def runner(outfile: str = "stats.csv", poleRate: float = 0.1):
    """
    Runs while your executable is still running and logs info
    about running process to a csv file.

    Args:
        outfile (str, optional): output filename. Defaults to "stats.csv".
        poleRate (float, optional): Time to sleep before getting new data. Defaults to 0.1.
    """

    num_cpus = len(read_cgroup_cpu())

    sleep(2)

    stats_file = open(outfile, "w")
    
    ftm_writer = "{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}\n"
    header = ["datetime", "pid", "name", "num_threads", "cpu_percent", "cpu_t_user", "cpu_t_system", "cpu_num",
        "mem_rss", "mem_vms", "mem_shared", "mem_percentage",
        "num_fds", "read_count", "write_count", "read_chars", "write_chars"]
    stats_file.write(ftm_writer.format(*header))

    # Keep pulling data from the process while it's running
    killer = GracefulKiller()
    while not killer.kill_now:
        user_procs = get_all_user_procs()
        for p in user_procs:
            try:
                proc = psutil.Process(p)
                pData = proc.as_dict()
                if 'io_counters' in pData:
                    if pData['io_counters'] != None:
                        read_count = pData['io_counters'].read_count 
                        write_count = pData['io_counters'].write_count
                        read_chars = pData['io_counters'].read_chars
                        write_chars = pData['io_counters'].write_chars
                    else:
                        read_count = "nan" 
                        write_count = "nan" 
                        read_chars = "nan" 
                        write_chars = "nan" 

                # Add new line to the file with relevant data
                stats_file.write(ftm_writer.format(
                    datetime.now().strftime("%m-%d-%Y %H:%M:%S.%f"),
                    p,
                    pData['name'],
                    pData['num_threads'],
                    pData['cpu_percent'],
                    pData['cpu_times'].user,
                    pData['cpu_times'].system,
                    pData['cpu_num'],
                    pData['memory_info'].rss,
                    pData['memory_info'].vms,
                    pData['memory_info'].shared if 'shared' in pData['memory_info'] else "nan",
                    pData['memory_percent'],
                    pData['num_fds'],
                    read_count,
                    write_count,
                    read_chars,
                    write_chars
                ))

            except psutil.NoSuchProcess:
                continue
            except Exception as e:
                print(e)
                # Breaks out of just the loop and not the function

        # Sleep for a number of seconds before going to the next loop
        sleep(poleRate)

    # Finally we close the file.
    stats_file.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--tag", type=str,
                        help="Tags the process and gives to the statistcs csv file.",
                        default="stats")
    parser.add_argument("-o", "--outfile", type=str,
                        help="Full path to output file name for csv.",
                        default=None)
    parser.add_argument("-p", "--path", type=str,
                        help="Path to put csv file.",
                        default="./")                 
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Run with debugging info.",
                        default=False)
    parser.add_argument("-r", "--rate", type=float,
                        help="Polling rate for process.", default=0.1)

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(
            format='%(asctime)s %(levelname)s ==> %(message)s', level=logging.INFO)
    else:
        logging.basicConfig(level=logging.FATAL)

    nowtime = datetime.now().strftime("%m-%d-%Y-%H.%M.%S")

    # Make out output stats csv name
    if args.outfile is not None:
        outfile = args.outfile
    elif args.tag is not None:
        outfile = f'{args.tag}_{nowtime}.csv'
    else:
        outfile = f'stats_{nowtime}.csv'

    logging.info(f'Saving csv to {outfile}')
    logging.info(f'Using tag {args.tag}')

    runner(outfile=outfile, poleRate=args.rate)
